From 88f7b2f1ec9cb29e607c85b70d59d24c8c40bc11 Mon Sep 17 00:00:00 2001
From: Joey Jiao <quic_jiangenj@quicinc.com>
Date: Wed, 25 May 2022 16:34:35 +0800
Subject: [PATCH] pkg/cover: only use function in text section

---
 docs/coverage.md           |   2 +-
 pkg/cover/backend/dwarf.go | 303 ++++++++++++++++++++++++++++++++++++++-
 pkg/cover/backend/elf.go   | 347 +++++----------------------------------------
 pkg/cover/html.go          |  12 +-
 pkg/cover/report.go        |  13 +-
 5 files changed, 348 insertions(+), 329 deletions(-)

diff --git a/docs/coverage.md b/docs/coverage.md
index 33bbdb2..b0fd83c 100644
--- a/docs/coverage.md
+++ b/docs/coverage.md
@@ -22,7 +22,7 @@ See [this](linux/coverage.md) for Linux kernel specific coverage information.
 
 ## Web Interface
 
-When clicking on `cover` link you get view showing each directory located in your kernel build directory. It's showing either percentage number `X%(Y%) of N(M)` or `---`. `X% of N` means that `X%` of `N` coverage points are covered so far, . `---` indicates there is no coverage in that directory. `Y% of M` means that `Y%` of `M` coverage points in covered function (function.covered >0) so far.
+When clicking on `cover` link you get view showing each directory located in your kernel build directory. It's showing either percentage number `X%(Y%) of N(M)` or `---`. `X% of N` means that `X%` of `N` coverage points are covered so far, . `---` indicates there is no coverage in that directory. `Y% of M` means that `Y%` of `M` coverage points in covered function (function.covered > 0) so far.
 
 Directory can be clicked and you get view on files and possible subdirectories. On each source code file there is again either `---` or coverage percentage.
 If [`xxx`] is shown, it means the file is belong to kernel module `xxx`.
diff --git a/pkg/cover/backend/dwarf.go b/pkg/cover/backend/dwarf.go
index 049ea08..07b162b 100644
--- a/pkg/cover/backend/dwarf.go
+++ b/pkg/cover/backend/dwarf.go
@@ -163,9 +163,11 @@ func makeDWARFUnsafe(target *targets.Target, objDir, srcDir, buildDir string,
 		}
 	}
 	sort.Slice(allRanges, func(i, j int) bool {
-		return allRanges[i].Start < allRanges[j].Start
+		if allRanges[i].End != allRanges[j].End {
+			return allRanges[i].End < allRanges[j].End
+		}
+		return allRanges[i].Start > allRanges[j].Start
 	})
-
 	allUnits = buildSymbols(allSymbols, allRanges, allCoverPoints)
 	for _, s := range allSymbols {
 		// TODO: objDir won't work for out-of-tree modules.
@@ -204,7 +206,7 @@ func buildSymbols(symbols []*Symbol, ranges []*DwarfRange, coverPoints [2][]uint
 	}
 	allUnits := make(map[string]map[string]*CompileUnit)
 	var units []*CompileUnit
-	log.Logf(0, "start buildSymbols for %d symbols %d ranges and [%d %d] pcs", len(symbols), len(ranges), len(coverPoints[0]), len(coverPoints[1]))
+	log.Logf(1, "start buildSymbols for %d symbols %d ranges and [%d %d] pcs", len(symbols), len(ranges), len(coverPoints[0]), len(coverPoints[1]))
 	for pcType := range coverPoints {
 		pcs := coverPoints[pcType]
 		if len(pcs) == 0 {
@@ -215,8 +217,20 @@ func buildSymbols(symbols []*Symbol, ranges []*DwarfRange, coverPoints [2][]uint
 			idx := sort.Search(len(ranges), func(i int) bool {
 				return pc < ranges[i].Start
 			})
+			if idx == 0 {
+				continue
+			}
 			idx--
-			symb := ranges[idx].Symbol
+			var symb *Symbol
+			for j := idx; j < len(ranges); j++ {
+				if pc >= ranges[j].Symbol.Start && pc < ranges[j].Symbol.End {
+					symb = ranges[j].Symbol
+					break
+				}
+			}
+			if symb == nil {
+				continue
+			}
 			sPCs := selectPCs(&symb.ObjectUnit, pcType)
 			*sPCs = append(*sPCs, pc)
 		}
@@ -256,12 +270,12 @@ func buildSymbols(symbols []*Symbol, ranges []*DwarfRange, coverPoints [2][]uint
 	for _, pcs1 := range coverPoints {
 		for _, pc := range pcs1 {
 			if !uniqPCs[pc] {
-				log.Logf(0, "pc 0x%x not found in any function\n", pc)
+				log.Logf(1, "pc 0x%x not found in any function\n", pc)
 			}
 		}
 	}
 
-	log.Logf(0, "finish buildSymbols for len(uniqPCs)=%d", len(uniqPCs))
+	log.Logf(1, "finish buildSymbols for len(uniqPCs)=%d", len(uniqPCs))
 
 	return units
 }
@@ -600,3 +614,280 @@ func archCallInsn(target *targets.Target) ([][]byte, [][]byte) {
 		panic(fmt.Sprintf("unknown arch %q", target.Arch))
 	}
 }
+
+type DwarfCompileUnit struct {
+	Entry   *dwarf.Entry
+	Name    string
+	Ranges  [][2]uint64
+	Offset  dwarf.Offset
+	CompDir string
+}
+
+type DwarfFunction struct {
+	DwarfCompileUnit *DwarfCompileUnit
+	Type             dwarf.Tag
+	Name             string
+	Ranges           [][2]uint64
+	DeclFile         string
+	AbstractOrigin   dwarf.Offset
+	Inline           bool
+	Offset           dwarf.Offset
+}
+
+func getFilenameByIndex(debugInfo *dwarf.Data, entry *dwarf.Entry, index int) (string, error) {
+	r, err := debugInfo.LineReader(entry)
+	if err != nil {
+		return "", fmt.Errorf("not found line reader for Compile Unit")
+	}
+	files := r.Files()
+	if files == nil {
+		return "", fmt.Errorf("files == nil")
+	}
+	if index >= len(files) {
+		return "", fmt.Errorf("index (%v) >= len(files) (%v)", index, len(files))
+	}
+	if index == 0 {
+		return "", nil
+	}
+	return files[index].Name, nil
+}
+
+func readAllCompileUnits(debugInfo *dwarf.Data) ([]*DwarfCompileUnit, error) {
+	var data []*DwarfCompileUnit
+
+	for r := debugInfo.Reader(); ; {
+		ent, err := r.Next()
+		if err != nil {
+			return nil, err
+		}
+		if ent == nil {
+			break
+		}
+		if ent.Tag != dwarf.TagCompileUnit {
+			return nil, fmt.Errorf("found unexpected tag %v on top level", ent.Tag)
+		}
+		attrName := ent.Val(dwarf.AttrName)
+		if attrName == nil {
+			continue
+		}
+		ranges, err := debugInfo.Ranges(ent)
+		if err != nil {
+			return nil, err
+		}
+		data = append(data, &DwarfCompileUnit{
+			Entry:   ent,
+			Name:    attrName.(string),
+			Ranges:  ranges,
+			Offset:  ent.Offset,
+			CompDir: ent.Val(dwarf.AttrCompDir).(string),
+		})
+		r.SkipChildren()
+	}
+
+	return data, nil
+}
+
+func getEntryByOffset(debugInfo *dwarf.Data, offset dwarf.Offset) (*dwarf.Entry, error) {
+	r := debugInfo.Reader()
+	r.Seek(offset)
+	return r.Next()
+}
+
+func readAllSubprograms(debugInfo *dwarf.Data, compileUnit *DwarfCompileUnit) ([]*DwarfFunction, error) {
+	var data []*DwarfFunction
+
+	top := true
+	first := true
+	for r := debugInfo.Reader(); ; {
+		if top {
+			r.Seek(compileUnit.Offset)
+			top = false
+		}
+		ent, err := r.Next()
+		if err != nil {
+			return nil, err
+		}
+		if ent == nil {
+			break
+		}
+		if first && ent.Tag == dwarf.TagCompileUnit {
+			first = false
+			continue
+		} else if ent.Tag == dwarf.TagCompileUnit {
+			break
+		}
+		if ent.Tag != dwarf.TagSubprogram {
+			continue
+		}
+
+		attrName := ent.Val(dwarf.AttrName)
+		attrAbstractOrigin := ent.Val(dwarf.AttrAbstractOrigin)
+		var decfile string
+		if attrName == nil && attrAbstractOrigin != nil {
+			ent1, err := getEntryByOffset(debugInfo, attrAbstractOrigin.(dwarf.Offset))
+			if err != nil {
+				return nil, err
+			}
+			attrName = ent1.Val(dwarf.AttrName)
+			decfile, err = getFilenameByIndex(debugInfo, compileUnit.Entry, int(ent1.Val(dwarf.AttrDeclFile).(int64)))
+			if err != nil {
+				return nil, err
+			}
+		}
+		if attrName == nil {
+			continue
+		}
+		if decfile == "" && ent.Val(dwarf.AttrDeclFile) != nil {
+			decfile, err = getFilenameByIndex(debugInfo, compileUnit.Entry, int(ent.Val(dwarf.AttrDeclFile).(int64)))
+			if err != nil {
+				return nil, err
+			}
+		}
+		ranges, err := debugInfo.Ranges(ent)
+		if err != nil {
+			return nil, err
+		}
+		inline := false
+		attrInline := ent.Val(dwarf.AttrInline)
+		if attrInline != nil {
+			inline = true
+		}
+
+		data = append(data, &DwarfFunction{
+			DwarfCompileUnit: compileUnit,
+			Type:             dwarf.TagSubprogram,
+			Name:             attrName.(string),
+			Ranges:           ranges,
+			DeclFile:         decfile,
+			Inline:           inline,
+			Offset:           ent.Offset,
+		})
+		r.SkipChildren()
+	}
+
+	return data, nil
+}
+
+func readAllInlinedSubroutines(debugInfo *dwarf.Data, inlineSubprograms map[dwarf.Offset]*DwarfFunction,
+	subprogram *DwarfFunction) ([]*DwarfFunction, error) {
+	var data []*DwarfFunction
+
+	top := true
+	first := true
+	for r := debugInfo.Reader(); ; {
+		if top {
+			r.Seek(subprogram.Offset)
+			top = false
+		}
+		ent, err := r.Next()
+		if err != nil {
+			return nil, err
+		}
+		if ent == nil {
+			break
+		}
+		if first && ent.Tag == dwarf.TagSubprogram {
+			first = false
+			continue
+		} else if ent.Tag == dwarf.TagSubprogram {
+			break
+		}
+		if ent.Tag != dwarf.TagInlinedSubroutine {
+			continue
+		}
+		attrAbstractOrigin := ent.Val(dwarf.AttrAbstractOrigin)
+		if attrAbstractOrigin == nil {
+			continue
+		}
+		df := inlineSubprograms[attrAbstractOrigin.(dwarf.Offset)]
+		ranges, err := debugInfo.Ranges(ent)
+		if err != nil {
+			return nil, err
+		}
+		if len(ranges) == 0 {
+			continue
+		}
+		data = append(data, &DwarfFunction{
+			DwarfCompileUnit: df.DwarfCompileUnit,
+			Type:             dwarf.TagInlinedSubroutine,
+			Name:             df.Name,
+			Ranges:           ranges,
+			Offset:           ent.Offset,
+			DeclFile:         df.DeclFile,
+			Inline:           df.Inline,
+			AbstractOrigin:   attrAbstractOrigin.(dwarf.Offset),
+		})
+	}
+
+	return data, nil
+}
+
+func readSymbolsFromDwarf(debugInfo *dwarf.Data, textSymbols map[string]bool) ([]*DwarfFunction, error) {
+	var allSubprograms []*DwarfFunction
+	var allInlineSubroutines []*DwarfFunction
+	compileUnits, err := readAllCompileUnits(debugInfo)
+	if err != nil {
+		return nil, err
+	}
+	for _, cu := range compileUnits {
+		errc := make(chan error, 1)
+		go func(cu *DwarfCompileUnit) {
+			subprograms, err := readAllSubprograms(debugInfo, cu)
+			if err != nil {
+				errc <- err
+				return
+			}
+			var textSubPrograms []*DwarfFunction
+			for _, subprogram := range subprograms {
+				if ok := textSymbols[subprogram.Name]; ok {
+					textSubPrograms = append(textSubPrograms, subprogram)
+					continue
+				}
+			}
+			allSubprograms = append(allSubprograms, textSubPrograms...)
+			inlineSubprograms := make(map[dwarf.Offset]*DwarfFunction)
+			for _, sp := range subprograms {
+				if sp.Inline {
+					inlineSubprograms[sp.Offset] = sp
+				}
+			}
+			for _, sp := range textSubPrograms {
+				if sp.Inline {
+					continue
+				}
+				erric := make(chan error, 1)
+				go func(sp *DwarfFunction) {
+					inlineSubroutines, err := readAllInlinedSubroutines(debugInfo, inlineSubprograms, sp)
+					if err != nil {
+						erric <- err
+						return
+					}
+					allInlineSubroutines = append(allInlineSubroutines, inlineSubroutines...)
+					erric <- nil
+				}(sp)
+				if err := <-erric; err != nil {
+					errc <- err
+				}
+			}
+			errc <- nil
+		}(cu)
+		if err := <-errc; err != nil {
+			return nil, err
+		}
+	}
+	var allDwarfFunctions []*DwarfFunction
+	for _, df := range allSubprograms {
+		if len(df.Ranges) == 0 {
+			continue
+		}
+		allDwarfFunctions = append(allDwarfFunctions, df)
+	}
+	for _, df := range allInlineSubroutines {
+		if len(df.Ranges) == 0 {
+			continue
+		}
+		allDwarfFunctions = append(allDwarfFunctions, df)
+	}
+
+	return allDwarfFunctions, nil
+}
diff --git a/pkg/cover/backend/elf.go b/pkg/cover/backend/elf.go
index e83e805..7f806c1 100644
--- a/pkg/cover/backend/elf.go
+++ b/pkg/cover/backend/elf.go
@@ -4,7 +4,6 @@
 package backend
 
 import (
-	"debug/dwarf"
 	"debug/elf"
 	"encoding/binary"
 	"fmt"
@@ -27,219 +26,6 @@ func makeELF(target *targets.Target, objDir, srcDir, buildDir string,
 	)
 }
 
-type DwarfCompileUnit struct {
-	Entry   *dwarf.Entry
-	Name    string
-	Ranges  [][2]uint64
-	Offset  dwarf.Offset
-	CompDir string
-}
-
-type DwarfFunction struct {
-	ParentDwarfFunction *DwarfFunction
-	DwarfCompileUnit    *DwarfCompileUnit
-	Type                dwarf.Tag
-	Name                string
-	Ranges              [][2]uint64
-	DeclFile            string
-	AbstractOrigin      dwarf.Offset
-	Inline              bool
-	Offset              dwarf.Offset
-}
-
-func getFilenameByIndex(debugInfo *dwarf.Data, entry *dwarf.Entry, index int) (string, error) {
-	r, err := debugInfo.LineReader(entry)
-	if err != nil {
-		return "", fmt.Errorf("not found line reader for Compile Unit")
-	}
-	files := r.Files()
-	if files == nil {
-		return "", fmt.Errorf("files == nil")
-	}
-	if index >= len(files) {
-		return "", fmt.Errorf("index (%v) >= len(files) (%v)", index, len(files))
-	}
-	if index == 0 {
-		return "", nil
-	}
-	return files[index].Name, nil
-}
-
-func readAllCompileUnits(debugInfo *dwarf.Data) ([]*DwarfCompileUnit, error) {
-	var data []*DwarfCompileUnit
-
-	for r := debugInfo.Reader(); ; {
-		ent, err := r.Next()
-		if err != nil {
-			return nil, err
-		}
-		if ent == nil {
-			break
-		}
-		if ent.Tag != dwarf.TagCompileUnit {
-			return nil, fmt.Errorf("found unexpected tag %v on top level", ent.Tag)
-		}
-		attrName := ent.Val(dwarf.AttrName)
-		if attrName == nil {
-			continue
-		}
-		ranges, err := debugInfo.Ranges(ent)
-		if err != nil {
-			return nil, err
-		}
-		data = append(data, &DwarfCompileUnit{
-			Entry:   ent,
-			Name:    attrName.(string),
-			Ranges:  ranges,
-			Offset:  ent.Offset,
-			CompDir: ent.Val(dwarf.AttrCompDir).(string),
-		})
-		r.SkipChildren()
-	}
-
-	return data, nil
-}
-
-func getEntryByOffset(debugInfo *dwarf.Data, offset dwarf.Offset) (*dwarf.Entry, error) {
-	r := debugInfo.Reader()
-	r.Seek(offset)
-	ent, err := r.Next()
-	if err != nil {
-		return nil, err
-	}
-	return ent, nil
-}
-
-func readAllSubprograms(debugInfo *dwarf.Data, compileUnit *DwarfCompileUnit) ([]*DwarfFunction, error) {
-	var data []*DwarfFunction
-
-	top := true
-	first := true
-	for r := debugInfo.Reader(); ; {
-		if top {
-			r.Seek(compileUnit.Offset)
-			top = false
-		}
-		ent, err := r.Next()
-		if err != nil {
-			return nil, err
-		}
-		if ent == nil {
-			break
-		}
-		if first && ent.Tag == dwarf.TagCompileUnit {
-			first = false
-			continue
-		} else if ent.Tag == dwarf.TagCompileUnit {
-			break
-		}
-		if ent.Tag != dwarf.TagSubprogram {
-			continue
-		}
-
-		attrName := ent.Val(dwarf.AttrName)
-		attrAbstractOrigin := ent.Val(dwarf.AttrAbstractOrigin)
-		var decfile string
-		if attrName == nil && attrAbstractOrigin != nil {
-			ent1, err := getEntryByOffset(debugInfo, attrAbstractOrigin.(dwarf.Offset))
-			if err != nil {
-				return nil, err
-			}
-			attrName = ent1.Val(dwarf.AttrName)
-			decfile, err = getFilenameByIndex(debugInfo, compileUnit.Entry, int(ent1.Val(dwarf.AttrDeclFile).(int64)))
-			if err != nil {
-				return nil, err
-			}
-		}
-		if attrName == nil {
-			continue
-		}
-		if decfile == "" && ent.Val(dwarf.AttrDeclFile) != nil {
-			decfile, err = getFilenameByIndex(debugInfo, compileUnit.Entry, int(ent.Val(dwarf.AttrDeclFile).(int64)))
-			if err != nil {
-				return nil, err
-			}
-		}
-		ranges, err := debugInfo.Ranges(ent)
-		if err != nil {
-			return nil, err
-		}
-		inline := false
-		attrInline := ent.Val(dwarf.AttrInline)
-		if attrInline != nil {
-			inline = true
-		}
-
-		data = append(data, &DwarfFunction{
-			DwarfCompileUnit: compileUnit,
-			Type:             dwarf.TagSubprogram,
-			Name:             attrName.(string),
-			Ranges:           ranges,
-			DeclFile:         decfile,
-			Inline:           inline,
-			Offset:           ent.Offset,
-		})
-		r.SkipChildren()
-	}
-
-	return data, nil
-}
-
-func readAllInlinedSubroutines(debugInfo *dwarf.Data, inlineSubprograms map[dwarf.Offset]*DwarfFunction,
-	subprogram *DwarfFunction) ([]*DwarfFunction, error) {
-	var data []*DwarfFunction
-
-	top := true
-	first := true
-	for r := debugInfo.Reader(); ; {
-		if top {
-			r.Seek(subprogram.Offset)
-			top = false
-		}
-		ent, err := r.Next()
-		if err != nil {
-			return nil, err
-		}
-		if ent == nil {
-			break
-		}
-		if first && ent.Tag == dwarf.TagSubprogram {
-			first = false
-			continue
-		} else if ent.Tag == dwarf.TagSubprogram {
-			break
-		}
-		if ent.Tag != dwarf.TagInlinedSubroutine {
-			continue
-		}
-		attrAbstractOrigin := ent.Val(dwarf.AttrAbstractOrigin)
-		if attrAbstractOrigin == nil {
-			continue
-		}
-		df := inlineSubprograms[attrAbstractOrigin.(dwarf.Offset)]
-		ranges, err := debugInfo.Ranges(ent)
-		if err != nil {
-			return nil, err
-		}
-		if len(ranges) == 0 {
-			continue
-		}
-		data = append(data, &DwarfFunction{
-			ParentDwarfFunction: subprogram,
-			DwarfCompileUnit:    df.DwarfCompileUnit,
-			Type:                dwarf.TagInlinedSubroutine,
-			Name:                df.Name,
-			Ranges:              ranges,
-			Offset:              ent.Offset,
-			DeclFile:            df.DeclFile,
-			Inline:              df.Inline,
-			AbstractOrigin:      attrAbstractOrigin.(dwarf.Offset),
-		})
-	}
-
-	return data, nil
-}
-
 func elfReadSymbols(module *Module, info *symbolInfo) ([]*Symbol, error) {
 	file, err := elf.Open(module.Path)
 	if err != nil {
@@ -259,27 +45,37 @@ func elfReadSymbols(module *Module, info *symbolInfo) ([]*Symbol, error) {
 	}
 	info.textAddr = text.Addr
 	for i, symb := range allSymbols {
-		flag := symb.Value >= text.Addr && symb.Value+symb.Size <= text.Addr+text.Size
+		text := symb.Value >= text.Addr && symb.Value+symb.Size <= text.Addr+text.Size
 		if strings.HasPrefix(symb.Name, "__sanitizer_cov_trace_") {
 			if symb.Name == "__sanitizer_cov_trace_pc" {
 				info.tracePCIdx[i] = true
-				if flag {
+				if text {
 					info.tracePC = symb.Value
 				}
 			} else {
 				info.traceCmpIdx[i] = true
-				if flag {
+				if text {
 					info.traceCmp[symb.Value] = true
 				}
 			}
 		}
 	}
 
-	compileUnits, err := readAllCompileUnits(debugInfo)
-	if err != nil {
-		return nil, err
+	textSecIdx := 0
+	for i, sec := range file.Sections {
+		if sec.Name == ".text" {
+			textSecIdx = i
+		}
+	}
+	textSymbols := make(map[string]bool)
+	for _, s := range allSymbols {
+		if s.Info&0xf == uint8(elf.STT_FUNC) {
+			if s.Section == elf.SectionIndex(textSecIdx) {
+				textSymbols[s.Name] = true
+			}
+		}
 	}
-	allDwarfFunctions, err := elfReadSymbolsFromDwarf(debugInfo, compileUnits)
+	allDwarfFunctions, err := readSymbolsFromDwarf(debugInfo, textSymbols)
 	if err != nil {
 		return nil, err
 	}
@@ -290,7 +86,6 @@ func elfReadSymbols(module *Module, info *symbolInfo) ([]*Symbol, error) {
 		}
 		start := ds.Ranges[0][0]
 		end := ds.Ranges[len(ds.Ranges)-1][1]
-		flag := start >= text.Addr && end <= text.Addr+text.Size
 		var ranges [][2]uint64
 		for _, r := range ds.Ranges {
 			ranges = append(ranges, [2]uint64{
@@ -298,103 +93,27 @@ func elfReadSymbols(module *Module, info *symbolInfo) ([]*Symbol, error) {
 				r[1] + module.Addr,
 			})
 		}
-		symbols = append(symbols, &Symbol{
-			Module: module,
-			ObjectUnit: ObjectUnit{
-				Name: ds.Name,
-			},
-			Start:  start + module.Addr,
-			End:    end + module.Addr,
-			Ranges: ranges,
-			Inline: ds.Inline,
-			Unit: &CompileUnit{
+		text := start >= text.Addr && end <= text.Addr+text.Size
+		if text {
+			symbols = append(symbols, &Symbol{
 				Module: module,
 				ObjectUnit: ObjectUnit{
-					Name: ds.DeclFile,
+					Name: ds.Name,
 				},
-			},
-			IsTextSection: flag,
-		})
-	}
-	return symbols, nil
-}
-
-func elfReadSymbolsFromDwarf(debugInfo *dwarf.Data, compileUnits []*DwarfCompileUnit) ([]*DwarfFunction, error) {
-	var allSubprograms []*DwarfFunction
-	var allInlineSubroutines []*DwarfFunction
-	for _, cu := range compileUnits {
-		errc := make(chan error, 1)
-		go func(cu *DwarfCompileUnit) {
-			subprograms, err := readAllSubprograms(debugInfo, cu)
-			if err != nil {
-				errc <- err
-				return
-			}
-			allSubprograms = append(allSubprograms, subprograms...)
-			inlineSubprograms := make(map[dwarf.Offset]*DwarfFunction)
-			for _, sp := range subprograms {
-				if sp.Inline {
-					inlineSubprograms[sp.Offset] = sp
-				}
-			}
-			for _, sp := range subprograms {
-				if sp.Inline {
-					continue
-				}
-				erric := make(chan error, 1)
-				go func(sp *DwarfFunction) {
-					inlineSubroutines, err := readAllInlinedSubroutines(debugInfo, inlineSubprograms, sp)
-					if err != nil {
-						erric <- err
-						return
-					}
-					allInlineSubroutines = append(allInlineSubroutines, inlineSubroutines...)
-					erric <- nil
-				}(sp)
-				if err := <-erric; err != nil {
-					errc <- err
-				}
-			}
-			errc <- nil
-		}(cu)
-		if err := <-errc; err != nil {
-			return nil, err
-		}
-	}
-	var allDwarfFunctions []*DwarfFunction
-	for _, df := range allSubprograms {
-		if len(df.Ranges) == 0 {
-			continue
-		}
-		allDwarfFunctions = append(allDwarfFunctions, df)
-	}
-	for _, df := range allInlineSubroutines {
-		if len(df.Ranges) == 0 {
-			continue
-		}
-		allDwarfFunctions = append(allDwarfFunctions, df)
-		var pranges [][2]uint64
-		for _, r := range df.Ranges {
-			for _, pr := range df.ParentDwarfFunction.Ranges {
-				if r[0] >= pr[0] && r[1] <= pr[1] {
-					if pr[0] != r[0] {
-						pranges = append(pranges, [2]uint64{
-							pr[0], r[0],
-						})
-					}
-					if pr[1] != r[1] {
-						pranges = append(pranges, [2]uint64{
-							r[1], pr[1],
-						})
-					}
-					break
-				}
-			}
-			df.ParentDwarfFunction.Ranges = pranges
+				Start:  start + module.Addr,
+				End:    end + module.Addr,
+				Ranges: ranges,
+				Inline: ds.Inline,
+				Unit: &CompileUnit{
+					Module: module,
+					ObjectUnit: ObjectUnit{
+						Name: ds.DeclFile,
+					},
+				},
+			})
 		}
 	}
-
-	return allDwarfFunctions, nil
+	return symbols, nil
 }
 
 func elfReadTextData(module *Module) ([]byte, error) {
diff --git a/pkg/cover/html.go b/pkg/cover/html.go
index b8b5a79..70c3d65 100644
--- a/pkg/cover/html.go
+++ b/pkg/cover/html.go
@@ -76,8 +76,8 @@ func (rg *ReportGenerator) DoHTML(w io.Writer, progs []Prog, coverFilter map[uin
 	}
 	haveProgs := len(progs) > 1 || progs[0].Data != ""
 	fileOpenErr := fmt.Errorf("failed to open/locate any source file")
-	for _, files1 := range files {
-		for fname, file := range files1 {
+	for _, mfiles := range files {
+		for fname, file := range mfiles {
 			if filter["module"] != "" {
 				if filter["module"] != file.module {
 					continue
@@ -366,8 +366,8 @@ func (rg *ReportGenerator) convertToStats(progs []Prog, filter map[string]string
 	}
 
 	var data []fileStats
-	for _, files1 := range files {
-		for fname, file := range files1 {
+	for _, mfiles := range files {
+		for fname, file := range mfiles {
 			if filter["module"] != "" {
 				if filter["module"] != file.module {
 					continue
@@ -776,8 +776,8 @@ func (rg *ReportGenerator) DoFuncCover(w io.Writer, progs []Prog, coverFilter ma
 		return err
 	}
 	var data [][]string
-	for _, files1 := range files {
-		for fname, file := range files1 {
+	for _, mfiles := range files {
+		for fname, file := range mfiles {
 			if filter["module"] != "" {
 				if filter["module"] != file.module {
 					continue
diff --git a/pkg/cover/report.go b/pkg/cover/report.go
index 40edfa5..ae9dfea 100644
--- a/pkg/cover/report.go
+++ b/pkg/cover/report.go
@@ -231,6 +231,15 @@ func (rg *ReportGenerator) findSymbol(pc uint64) *backend.Symbol {
 		return nil
 	}
 	idx--
-	s := rg.Ranges[idx].Symbol
-	return s
+	var symb *backend.Symbol
+	for j := idx; j < len(rg.Ranges); j++ {
+		if pc >= rg.Ranges[j].Symbol.Start && pc < rg.Ranges[j].Symbol.End {
+			symb = rg.Ranges[j].Symbol
+			break
+		}
+	}
+	if symb == nil {
+		return nil
+	}
+	return symb
 }
-- 
2.7.4

